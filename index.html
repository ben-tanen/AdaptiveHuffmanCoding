<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visualizing Adaptive Huffman Coding</title>
    <!-- <link rel="shortcut icon" type="image/x-icon" href="img/icon.png" /> -->

    <!-- importing jQuery, d3 v4, MathJax -->
    <script src="js/lib/jquery.min.js"></script>
    <script src="js/lib/d3.v4.min.js"></script>
    <script src="js/lib/graph-scroll.js"></script>
    <script src="js/lib/jBox.min.js"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        CommonHTML: {
            scale: 100
        },
        "HTML-CSS": {
            scale: 100
        },
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']]
        }
    });
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
    </script>
    
    <!-- styling -->
    <link rel="stylesheet" href="css/jBox.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway:300,400,500|Roboto+Mono:400,500">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="svg-container">
    </div>

    <div class="mask" id="basic">
        <div class="fixed-content hidden" id="freq-table">
            <table>
              <tr>
                <th width="16.67%">b</th>
                <th width="16.67%">e</th> 
                <th width="16.67%">k</th>
                <th width="16.67%">o</th>
                <th width="16.67%">p</th>
                <th width="16.67%">r</th>
              </tr>
              <tr>
                <td>1</td>
                <td>3</td> 
                <td>2</td>
                <td>2</td>
                <td>1</td>
                <td>1</td>
              </tr>
            </table>
        </div>

        <div class="header section">
            <h1>Visualizing Adaptive Huffman Coding</h1>
            <p>Ben Tanen Â· COMP-150</p>
        </div>

        <div class="section">
            <p>This is a visual explanation and exploration of adaptive Huffman coding and how it compares to traditional static Huffman coding. Specifically, we will focus on how our encoding trees might differ when using adaptive vs. static Huffman.</p>

            <p>First, we will explore how traditional Huffman coding builds its encoding tree for a specific string, in this case "bookkeeper". We will then do the same for adaptive Huffman coding using the FGK algorithm and compare these two trees. At the end, you can further explore how static vs. Huffman coding trees compare through other strings.</p>

            <p>Want to skip ahead? <a href='#fgk'>Click here</a> for the explanation of the adaptive FGK algorithm and <a href='#'>click here</a> to explore other words.</p>
        </div>

        <div class="section">
            <h3>What is Huffman Coding?</h3>

            <p>Before we get started, let's quickly discuss what exactly Huffman coding is. When we transmit information, we generally need to convert some sort of data (text, pictures, etc.) into binary. To do this, we assign codes to help us distinguish between different pieces of data.</p>

            <p>For example, if we had the string "abca", we might assign codes like: a = 00, b = 01, c = 10. This would make it so that our binary encoding of "abca" is "00 01 10 00".</p>
        </div>

        <div class="section">
            <p>But what if we wanted to encode "aabaacaa"? If we used our original encoding where we use two bits for each character, we would be treating "a" and "c" with equal importance, even though "a" appears much more.</p>

            <p>Wouldn't it be more efficient if we used fewer bits for "a" and more bits for "c"? This is where Huffman coding comes in.</p>
        </div>

        <div class="section">
            <p>Huffman coding is a lossless data compression algorithm that assigns variable-length codes based on the frequencies of our input characters.</p>

            <p>In order to determine what code to assign to each character, we will first build a binary tree that will organize our characters based on frequency.</p>
        </div>

        <div class="section">
            <h3>Building a Huffman Tree</h3>

            <p>As an example, let's encode the string "bookkeeper". Before we can start encoding, we will build our Huffman tree for this string, which will in turn show us what binary encoding we will use for each character.</p>

            <p>To start, we need to count the frequency for each character in our string and store these frequencies in a table.</p>
        </div>

        <div class="section">
            <p>We will use this table to add nodes and edges that will build up our tree.</p>

            <p>First, we start by adding leaf nodes for the two characters that occur the least. In this case, we have a tie between "b", "p", and "r", so we'll just arbitrarily choose "p" and "r".
        </div>

        <div class="section">
            <p>When we add in our leaves for "p" and "r", we will attach them to a parent node for a new pseudo-character "pr". This pseudo-character represents occurrences of "p" or "r" so it's frequency is equal to the frequency of "p" plus the frequency of "r".</p>

            <p>We will also update our table to include our new pseudo-character. We can get this by simply merging the columns of "p" and "r".</p>
        </div>

        <div class="section">
            <p>With a now reduced table, we can repeat this process again for our updated values.</p>

            <p>As we can see, "b" has the lowest frequency in our table so we'll use that. For the second lowest frequency, there is a tie between "k", "o", and "pr", so we can again pick arbitrarily. Let's use our pseudo-character "pr".</p>
        </div>

        <div class="section">
            <p>Because we don't have a leaf node for "b" yet, we will have to add that into our tree.</p>

            <p>Then, as we did before, we'll attach our "b" node and our "pr" node to a parent node for a new pseudo-character "bpr".</p>

            <p>Finally, we'll update our table to reflect our new pseudo-character.</p>
        </div>

        <div class="section">
            <p>It looks like our tree is coming along, but it doesn't quite have everything yet.</p>

            <p>To keep going, we can repeat this process again...</p>
        </div>

        <div class="section">
            <p style="text-align: center;">...and again</p>
        </div>

        <div class="section">
            <p style="text-align: center;">...and again</p>
        </div>

        <div class="section">
            <p>...until our table is only left with one value, a pseudo-character containing all of our original characters. This means we're done building our Huffman tree!</p>

            <p>So how do we use this tree to assign codes?</p>
        </div>

        <div class="section">
            <p">Given our Huffman tree, to determine the binary code that we will use for any particular character, we can simply walk from the root to our character's leaf node, taking note of when we traverse left and when we traverse right.</p>

            <p>As we walk from root to leaf, we will denote a left traversal with "0" and a right traversal with a "1".</p>
        </div>

        <div class="section">
            <p">For example, say we wanted to find the encoding for "p", which only occurs once in "bookkeeper".</p>

            <p>In our walk from root to the "p" leaf, we go left, right, right, and left again. This means we will use four bits to encode "p" as "0110".</p>
        </div>

        <div class="section">
            <p">What about our encoding of a more frequently used character like "k"?</p>

            <p>For our walk to "k", we traverse right then left. This means we will only use two bits to encode "k" as "10".</p>

            <p>It seems like our tree works - hooray for efficiency!</p>
        </div>

        <div class="section">
            <p>If we do this for all of our characters, we get our full binary encoding scheme. Let's compare this new Huffman scheme against a niave encoding scheme where we just arbitrarily assign binary codes.</p>

            <br />

            <table style="width: 80%">
                <tr>
                    <th>char</th>
                    <td>b</td>
                    <td>e</td>
                    <td>k</td>
                    <td>o</td>
                    <td>p</td>
                    <td>r</td>
                </tr>
                <tr>
                    <th>freq</th>
                    <td>1</td>
                    <td>3</td> 
                    <td>2</td>
                    <td>2</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <th>old code</th>
                    <td>000</td>
                    <td>001</td>
                    <td>010</td>
                    <td>011</td>
                    <td>100</td>
                    <td>101</td>
                </tr>
                <tr>
                    <th>new code</th>
                    <td>010</td>
                    <td>11</td>
                    <td>10</td>
                    <td>11</td>
                    <td>0110</td>
                    <td>0111</td>
                </tr>
            </table>

            <p>Using the niave scheme, encoding "bookkeeper" would take 30 bits. Using our Huffman scheme, we only use 25 bits to encode, which is a roughly a 17% improvement!
        </div>
    
        <div class="section">
            <p>So how does this tree and this encoding compare to the one produced using adaptive Huffman coding? Keep scrolling to find out!</p>

            <p>Want to skip around? <a href='#'>Click here</a> to head back to the beginning and <a href='#'>click here</a> to explore other words.</p>
        </div>
    </div>

    <div class="mask" id="fgk">
        <div class="section" name="fgk">
            <h3>Adaptive Huffman Coding</h3>
            <p>Nunc dignissim mi quis arcu malesuada, eu placerat lectus gravida. Praesent vestibulum et nisi ac consequat. Cras tincidunt, arcu sit amet pretium sagittis, lorem purus placerat arcu, sit amet egestas eros eros quis ipsum. Fusce eget dignissim sapien. Fusce mauris quam, feugiat vitae placerat non, placerat ut diam. Nunc efficitur auctor turpis nec bibendum. Nulla diam ante, commodo at ligula a, tristique mattis sem.</p>
        </div>

        <div class="section">
            <p>Morbi a metus arcu. Nullam in orci vel urna commodo tincidunt eget et dolor. Proin et sagittis enim. Etiam id ligula nec velit mattis lacinia. Praesent imperdiet in nibh quis auctor. Praesent ornare dui et sapien luctus condimentum. Mauris non lorem fringilla, ornare nibh vitae, porta ante. Nullam nec tristique urna. Maecenas eleifend erat a vehicula elementum. In posuere, lacus eu facilisis auctor, odio purus laoreet massa, vel egestas felis ex eu dui.</p>
        </div>
    </div>

    <div class="mask" id="end">
    </div>

    <div class="word-select">
        Select a word
        <select>
            <option value="bookkeeper">bookkeeper</option>
            <option value="mississippi">mississippi</option>
            <option value="engineering">engineering</option>
            <option value="sleeplessness">sleeplessness</option>
        </select>
    </div>

    <!-- javascript -->
    <script type="text/javascript" src="js/huffman.js"></script>
    <script type="text/javascript" src="js/poly.js"></script>
    <script type="text/javascript" src="js/scroll.js"></script>
    <script type="text/javascript" src="js/main.js"></script>

</body>
</html>